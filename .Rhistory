desaison <- xm-lag(xm,-12) #on enlève la saisonnalité
par(mfrow=c(1,2)) #pour mettre 2 graphiques
plot(desaison)
acf(desaison)
#### Q3 ####
acf(desaison) #autocorrelation
pacf(desaison) #partial autocorrelation
#semble statio car loin de 1, on est dans l'intervalle de confiance
#### Q4 ####
dev.off() #reinitialise les parametres des representations graphiques
plot(desaison) #on refait le graphique de la série, on a une série qui a l'air statio
#test unitaire de philippe perron car on veut voir si tendance particulière (on pense que non)
pp.test(desaison) #à 1% on rejette l'hypothèse que le modèle n'est aps stationnaire
#ici l'hyp nulle est celle de non stationnarité !!! donc important pour l'interpretation
#### Q5 ####
#on compte le nombre de lags avant de rentrer COMPLETEMENT dans l'intervalle
acf(desaison) #pour trouver q : 2 car on ne prend jamais en compte le premier bâton !! on compte à partir du 2e bâton quoi
pacf(desaison) #pour trouver p : 3
axis(side=1,at=seq(0,25))
#a priori pour acf ordre max est 2 : MA
#pour pacf ordre max 3 : AR
#IMPORTANT : PACF pour trouver p, ACF pour trouver q
#ici d = 0 car série stationnaire donc ARIMA(PACF, 0, ACF)
y <- desaison - mean(desaison) #
par(mfrow=c(1,2))
acf(y,24)
pacf(y,24)
#
arima(y,c(3,0,2)) #
arima302 <- arima(y,c(3,0,2)) #
#pour savoir si les lags sont corrélés : pour tester si la série est un bruit blanc
Box.test(arima302$residuals, lag=6, type="Ljung-Box", fitdf=5) #
#
#
#
#
Qtests <- function(series, k, fitdf=0) {
pvals <- apply(matrix(1:k), 1, FUN=function(l) {
pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
return(c("lag"=l,"pval"=pval))
})
return(t(pvals))
}
Qtests(arima302$residuals, 24, 5) #tests de LB pour les ordres 1 a 24
round(Qtests(arima302$residuals,24,fitdf=5),3)
#
#
#### Q6 ####
#
signif <- function(estim){ #fonction de test des significations individuelles des coefficients
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))*2
return(rbind(coef,se,pval))
}
signif(arima302) #
##
arimafit <- function(estim){
adjust <- round(signif(estim),3)
pvals <- Qtests(estim$residuals,24,length(estim$coef)-1)
pvals <- matrix(apply(matrix(1:24,nrow=6),2,function(c) round(pvals[c,],3)),nrow=6)
colnames(pvals) <- rep(c("lag", "pval"),4)
cat("tests de nullite des coefficients :\n")
print(adjust)
cat("\n tests d'absence d'autocorrelation des residus : \n")
print(pvals)
}
estim <- arima(y,c(1,0,0)); arimafit(estim)
#
estim <- arima(y,c(2,0,0)); arimafit(estim)
#
estim <- arima(y,c(3,0,0)); arimafit(estim)
#
ar3 <- estim
estim <- arima(y,c(0,0,1)); arimafit(estim)
#
estim <- arima(y,c(0,0,2)); arimafit(estim)
#
ma2 <- estim
estim <- arima(y,c(1,0,1)); arimafit(estim)
#
estim <- arima(y,c(1,0,2)); arimafit(estim)
#
estim <- arima(y,c(2,0,1)); arimafit(estim)
#
ar2ma1 <- estim
estim <- arima(y,c(2,0,2)); arimafit(estim)
#
#
models <- c("ar3","ma2","ar2ma1"); names(models) <- models
apply(as.matrix(models),1, function(m) c("AIC"=AIC(get(m)), "BIC"=BIC(get(m))))
#
#### Q7 ####
## matrice pour mettre nos predictions
models <-  c("ar3","ma2","ar2ma1")
preds <- zoo(matrix(NA,ncol=3,nrow=4),order.by=tail(index(xm.source),4))
colnames(preds) <- models
desaisonp <- preds #
xmp <- preds #
## prediction
for (m in models){
pred1 <- mean(desaison) + zoo(predict(get(m),4)$pred, order.by=tail(index(xm.source),4))
pred2 <- as.numeric(tail(xm,12))[1:4] + pred1
desaisonp[,m] <- pred1
xmp[,m] <- pred2
}
obs <- tail(xm.source,4) #
cbind(obs,xmp) #
apply(xmp,2, function(x) sqrt(sum((x-obs)^2)/4)/sd(xm.source)) #
#
#### Q8 ####
data <- read.csv("données2.csv",sep=";") #importe un fichier .csv dans un objet de classe data.frame
xm.source <- zoo(data[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
xm <- xm.source[1:(T-4)] #supprime les 4 dernieres valeurs
dev.off() #reinitialise les parametre de graphique
plot(xm)
###
trend <- 1:length(xm)
lt <- lm(xm ~ trend) #
summary(lt) #
r <- lt$residuals #
par(mfrow=c(1,2))
plot(r)
acf(r)
###
pp.test(xm)
###
acf(r,24);pacf(r,24)
###
###
pmax=4; qmax=21
###
## fonction pour estimer un arima et en verifier l'ajustement et la validite
modelchoice <- function(p,q,data=r, k=24){
estim <- try(arima(data, c(p,0,q),optim.control=list(maxit=20000)))
if (class(estim)=="try-error") return(c("p"=p,"q"=q,"arsignif"=NA,"masignif"=NA,"resnocorr"=NA, "ok"=NA))
arsignif <- if (p==0) NA else signif(estim)[3,p]<=0.05
masignif <- if (q==0) NA else signif(estim)[3,p+q]<=0.05
resnocorr <- sum(Qtests(estim$residuals,24,length(estim$coef)-1)[,2]<=0.05,na.rm=T)==0
checks <- c(arsignif,masignif,resnocorr)
ok <- as.numeric(sum(checks,na.rm=T)==(3-sum(is.na(checks))))
return(c("p"=p,"q"=q,"arsignif"=arsignif,"masignif"=masignif,"resnocorr"=resnocorr,"ok"=ok))
}
## fonction pour estimer et verifier tous les arima(p,q) avec p<=pmax et q<=max
armamodelchoice <- function(pmax,qmax){
pqs <- expand.grid(0:pmax,0:qmax)
t(apply(matrix(1:dim(pqs)[1]),1,function(row) {
p <- pqs[row,1]; q <- pqs[row,2]
cat(paste0("Computing ARMA(",p,",",q,") \n"))
modelchoice(p,q)
}))
}
armamodels <- armamodelchoice(pmax,qmax) #estime tous les arima (patienter...)
selec <- armamodels[armamodels[,"ok"]==1&!is.na(armamodels[,"ok"]),] #modeles bien ajustes et valides
selec
### On a ? modeles bien ajustes et valides
pqs <- apply(selec,1,function(row) list("p"=as.numeric(row[1]),"q"=as.numeric(row[2]))) #cree une liste des ordres p et q des modeles candidats
names(pqs) <- paste0("arma(",selec[,1],",",selec[,2],")") #renomme les elements de la liste
models <- lapply(pqs, function(pq) arima(r,c(pq[["p"]],0,pq[["q"]]))) #cree une liste des modeles candidats estimes
vapply(models, FUN.VALUE=numeric(2), function(m) c("AIC"=AIC(m),"BIC"=BIC(m))) #calcule les AIC et BIC des modeles candidats
### L'ARMA(?,?) minimise les criteres d'information.
rps <- lapply(models, function(m) as.zoo(predict(m,4)$pred)) #previsions de r
xmps <- lapply(rps, function(rp) rp+cbind(1,c((T-3):T))%*%lt$coefficients) #previsions de xm
rmse <- vapply(xmps, FUN.VALUE=numeric(1), function(xmp) sqrt(sum((as.zoo(xmp)-tail(xm.source,4))^2))) #calcule les rmse out-of-sample
rmse
### L'ARMA(?,?) fait aussi la meilleure prevision
#Manière de faire en général
#plotter les données pour repérer saisonnalités
#si pas stationnaire,on différencie et on refait les tests de statio
require(zoo)
require(tseries)
library(dplyr)
#fonctions utilisées dans le code
signif <- function(estim){ #fonction de test des significations individuelles des coefficients
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))*2
return(rbind(coef,se,pval))
}
selection_print <- function(pmax, qmax){
res_aic <- matrix(nrow=pmax, ncol=qmax)
for (p in 1:pmax){
for (q in 1:qmax){
model <- arima(xm, c(p,0, q))
res_aic[p,q] <- model$aic
print(c(p,q))
}}
return(res_aic)
}
selection_bis <- function(pmax, qmax){
p_0 <- numeric(length = qmax)
q_0 <- numeric(length = pmax)
for (q in 1:qmax){
p_0[q] <- arima(xm, c(0,0,q))$aic
}
for (p in 1:pmax){
q_0[p] <- arima(xm, c(p,0,0))$aic
}
return(list(p_0, q_0))
}
Qtests <- function(series, k, fitdf=0) {
pvals <- apply(matrix(1:k), 1, FUN=function(l) {
pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
return(c("lag"=l,"pval"=pval))
})
return(t(pvals))
}
#base de données
setwd("C:/Users/candi/Desktop/ETUDES/ENSAE2A/semestre 2/séries temporelles/series temp/series_temp")
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
test <- tail(xm.source, n=2) #pour comparer nos prévisions avec les vraies données
xm <- xm.source[(250):(T-2)] #pour le modèle
mean(xm.source)
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,400,12)) #pour mettre l'axe x
par(mfrow=c(1,2))
acf(xm)
pacf(xm) #saisonnalité apparente : saisonnalité de 12 donc annuelle, avec été et hiver différenciés (corr pos et neg)
dev.off()
pp.test(xm) #test de philippe perron, on rejette à 1% l'hypothèse que la série n'est pas stationnaire
#on retire la moyenne de xm
xm <- xm - mean(xm)
#on enlève la saisonnalité apparente
xm <- diff(xm, lag = 12)
par(mfrow=c(1,2))
acf(xm)
pacf(xm) #la saisonnalité a bien disparu
#on identifie avec l'acf et la pacf les ordres maximums à tester
pmax = 12
qmax = 11
#modèle
#estimation de tous les modèles
selec <- selection_print(pmax,qmax) #matrice qui renvoie les AIC de tous les modèles
arimafit <- function(estim){
adjust <- round(signif(estim),3)
pvals <- Qtests(estim$residuals,24,length(estim$coef)-1)
pvals <- matrix(apply(matrix(1:24,nrow=6),2,function(c) round(pvals[c,],3)),nrow=6)
colnames(pvals) <- rep(c("lag", "pval"),4)
cat("tests de nullite des coefficients :\n")
print(adjust)
cat("\n tests d'absence d'autocorrelation des residus : \n")
print(pvals)
}
#On choisit donc un modèle ARMA(5,11)
arma_fit <- arima(xm, c(5,0,11))
arimafit(arma_fit)
armamodelchoice <- function(pmax,qmax){
pqs <- expand.grid(0:pmax,0:qmax)
t(apply(matrix(1:dim(pqs)[1]),1,function(row) {
p <- pqs[row,1]; q <- pqs[row,2]
cat(paste0("Computing ARMA(",p,",",q,") \n"))
modelchoice(p,q)
}))
}
modelchoice <- function(data, p,q,data=r, k=24){
estim <- try(arima(data, c(p,0,q),optim.control=list(maxit=20000)))
if (class(estim)=="try-error") return(c("p"=p,"q"=q,"arsignif"=NA,"masignif"=NA,"resnocorr"=NA, "ok"=NA))
arsignif <- if (p==0) NA else signif(estim)[3,p]<=0.05
masignif <- if (q==0) NA else signif(estim)[3,p+q]<=0.05
resnocorr <- sum(Qtests(estim$residuals,24,length(estim$coef)-1)[,2]<=0.05,na.rm=T)==0
checks <- c(arsignif,masignif,resnocorr)
ok <- as.numeric(sum(checks,na.rm=T)==(3-sum(is.na(checks))))
return(c("p"=p,"q"=q,"arsignif"=arsignif,"masignif"=masignif,"resnocorr"=resnocorr,"ok"=ok))
}
modelchoice <- function(p,q,data=xm, k=24){
estim <- try(arima(data, c(p,0,q),optim.control=list(maxit=20000)))
if (class(estim)=="try-error") return(c("p"=p,"q"=q,"arsignif"=NA,"masignif"=NA,"resnocorr"=NA, "ok"=NA))
arsignif <- if (p==0) NA else signif(estim)[3,p]<=0.05
masignif <- if (q==0) NA else signif(estim)[3,p+q]<=0.05
resnocorr <- sum(Qtests(estim$residuals,24,length(estim$coef)-1)[,2]<=0.05,na.rm=T)==0
checks <- c(arsignif,masignif,resnocorr)
ok <- as.numeric(sum(checks,na.rm=T)==(3-sum(is.na(checks))))
return(c("p"=p,"q"=q,"arsignif"=arsignif,"masignif"=masignif,"resnocorr"=resnocorr,"ok"=ok))
}
## fonction pour estimer et verifier tous les arima(p,q) avec p<=pmax et q<=max
armamodelchoice <- function(pmax,qmax){
pqs <- expand.grid(0:pmax,0:qmax)
t(apply(matrix(1:dim(pqs)[1]),1,function(row) {
p <- pqs[row,1]; q <- pqs[row,2]
cat(paste0("Computing ARMA(",p,",",q,") \n"))
modelchoice(p,q)
}))
}
armamodelchoice(5,11)
arma_valid <- armamodelchoice(12,11)
selec <- arma_valid[arma_valid[,"ok"]==1&!is.na(arma_valid[,"ok"]),]
selec
arma_12_2 <- arima(xm, c(12,0,2))
arma_12_9 <- arima(xm, c(12,0,9))
arma_5_11 <- arima(xm, c(5,0,11))
arma_12_2$aic
arma_12_9$aic
arma_5_11$aic
BIC(arma_12_2)
BIC(arma_12_9)
BIC(arma_5_11)
#aic
arma_12_2$aic
arma_12_9$aic
arma_5_11$aic #modèle ayant le plus petit aic
#bic
BIC(arma_12_2)
BIC(arma_12_9)
BIC(arma_5_11) #modèle ayant le plus petit bic
selection_print_bic <- function(pmax, qmax){
res_bic <- matrix(nrow=pmax, ncol=qmax)
for (p in 1:pmax){
for (q in 1:qmax){
model <- arima(xm, c(p,0, q))
res_bic[p,q] <- BIC(model)
print(c(p,q))
}}
return(res_bic)
}
selec_bic <- selection_print_bic(pmax,qmax)
xtable((as.data.frame(selec_bic))%>%select(V1, V2, V3, V4, V5, V6, V7, V8, V9))
#export de la table de significativité des modèles pour le document latex
library(xtable)
xtable((as.data.frame(selec_bic))%>%select(V1, V2, V3, V4, V5, V6, V7, V8, V9))
xtable((as.data.frame(selec_bic))%>%select(V8, V9, V10, V11))
#causalité
arma_fit
#causalité
arma_fit$coef
#causalité
arma_fit$coef['ar1']
arma_fit$coef
#causalité
arma_fit$coef[c('ar1', 'ar2', 'ar3', 'ar4', 'ar5')]
#causalité
sort(arma_fit$coef[c('ar1', 'ar2', 'ar3', 'ar4', 'ar5')])
#causalité
polyroot(sort(arma_fit$coef[c('ar1', 'ar2', 'ar3', 'ar4', 'ar5')]))
#causalité
roots <- polyroot(sort(arma_fit$coef[c('ar1', 'ar2', 'ar3', 'ar4', 'ar5')]))
roots
Mod(roots)
modulud_roots <- Mod(roots)
modulus_roots <- Mod(roots)
modulus_roots
xtable(modulus_roots)
require(zoo)
require(tseries)
library(dplyr)
#fonctions utilisées dans le code
signif <- function(estim){ #fonction de test des significations individuelles des coefficients
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))*2
return(rbind(coef,se,pval))
}
Qtests <- function(series, k, fitdf=0) {
pvals <- apply(matrix(1:k), 1, FUN=function(l) {
pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
return(c("lag"=l,"pval"=pval))
})
return(t(pvals))
}
arimafit <- function(estim){
adjust <- round(signif(estim),3)
pvals <- Qtests(estim$residuals,24,length(estim$coef)-1)
pvals <- matrix(apply(matrix(1:24,nrow=6),2,function(c) round(pvals[c,],3)),nrow=6)
colnames(pvals) <- rep(c("lag", "pval"),4)
cat("tests de nullite des coefficients :\n")
print(adjust)
cat("\n tests d'absence d'autocorrelation des residus : \n")
print(pvals)
}
modelchoice <- function(p,q,data=xm, k=24){
estim <- try(arima(data, c(p,0,q),optim.control=list(maxit=20000)))
if (class(estim)=="try-error") return(c("p"=p,"q"=q,"arsignif"=NA,"masignif"=NA,"resnocorr"=NA, "ok"=NA))
arsignif <- if (p==0) NA else signif(estim)[3,p]<=0.05
masignif <- if (q==0) NA else signif(estim)[3,p+q]<=0.05
resnocorr <- sum(Qtests(estim$residuals,24,length(estim$coef)-1)[,2]<=0.05,na.rm=T)==0
checks <- c(arsignif,masignif,resnocorr)
ok <- as.numeric(sum(checks,na.rm=T)==(3-sum(is.na(checks))))
return(c("p"=p,"q"=q,"arsignif"=arsignif,"masignif"=masignif,"resnocorr"=resnocorr,"ok"=ok))
}
armamodelchoice <- function(pmax,qmax){
pqs <- expand.grid(0:pmax,0:qmax)
t(apply(matrix(1:dim(pqs)[1]),1,function(row) {
p <- pqs[row,1]; q <- pqs[row,2]
cat(paste0("Computing ARMA(",p,",",q,") \n"))
modelchoice(p,q)
}))
}
#base de données
setwd("C:/Users/candi/Desktop/ETUDES/ENSAE2A/semestre 2/séries temporelles/series temp/series_temp")
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
test <- tail(xm.source, n=2) #pour comparer nos prévisions avec les vraies données
xm <- xm.source[(250):(T-2)] #pour le modèle
mean(xm.source)
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,400,12)) #pour mettre l'axe x
par(mfrow=c(1,2))
acf(xm)
pacf(xm) #saisonnalité apparente : saisonnalité de 12 donc annuelle, avec été et hiver différenciés (corr pos et neg)
dev.off()
pp.test(xm) #test de philippe perron, on rejette à 1% l'hypothèse que la série n'est pas stationnaire
#on retire la moyenne de xm
xm <- xm - mean(xm)
#on enlève la saisonnalité apparente
xm <- diff(xm, lag = 12)
par(mfrow=c(1,2))
acf(xm)
pacf(xm) #la saisonnalité a bien disparu
#on identifie avec l'acf et la pacf les ordres maximums à tester
pmax = 12
qmax = 11
#modèle
#estimation de tous les modèles et sélection des modèles valides
arma_valid <- armamodelchoice(12,11)
selec <- arma_valid[arma_valid[,"ok"]==1&!is.na(arma_valid[,"ok"]),]
#les modèles possibles sont donnés par
selec
#on peut donc choisir p=12, q=2 ou p=12, q=9, ou p=5, q=11
#on fit les trois modèles et on calcule les aic
arma_12_2 <- arima(xm, c(12,0,2))
arma_12_9 <- arima(xm, c(12,0,9))
arma_5_11 <- arima(xm, c(5,0,11))
#aic
arma_12_2$aic
arma_12_9$aic
arma_5_11$aic #modèle ayant le plus petit aic
#bic
BIC(arma_12_2)
BIC(arma_12_9)
BIC(arma_5_11) #modèle ayant le plus petit bic
#valeurs sélectionnées pour notre modèle
p = 5
q = 11
#fit du modèle
arma_fit <- arima(xm, c(5,0,11))
arma_fit
#résidus
plot(arma_fit$residuals)
acf(arma_fit$residuals)
pacf(arma_fit$residuals)
hist(arma_fit$residuals)
library(forecast)
checkresiduals(arma_fit)
#Q test
#test
Qtests(arma_fit$residuals, 24, 5) #tests de LB pour les ordres 1 a 24
#on rejette le fait que les résidus soient corrélés
signific <- as.data.frame(signif(arma_fit))
#causalité
roots <- polyroot(sort(arma_fit$coef[c('ar1', 'ar2', 'ar3', 'ar4', 'ar5')]))
modulus_roots <- Mod(roots)
modulus_roots #les coefficients sont bien plus grands que 1 donc le modèle est causal
#prévision
model_pred <- predict(arma_fit, n.ahead=2)
serie_pred <- zoo(c(xm, model_pred$pred))
#graphiques
xm_all <- xm.source[250:T] - mean(xm.source[250:(T-2)])
xm_all <- diff(xm_all, lag = 12)
plot(xm_all, col = 'black', ylab = 'Série', main = 'Prévision des 2 prochaines valeurs de la série')
#lines(xm_all, col = 'black', type = 'p') pour avoir des ronds à chaque valeur de la série temporelle
U = model_pred$pred + 1.96*model_pred$se
L = model_pred$pred - 1.96*model_pred$se
xx = c(time (U), rev (time (U)))
yy = c(L, rev(U))
polygon(xx, yy, border = 8, col = gray (0.6, alpha=0.2))
lines(model_pred$pred, type = "p", col = "red")
lines(model_pred$pred, type = 'l', col = 'red')
legend("topleft", legend=c("Données réelles", "Prédiction"), col=c("red", "black"), lty=1:2, cex=0.4)
#export de la table de significativité des modèles pour le document latex
library(xtable)
xtable(signific)
xtable(signific %>% select(ar1, ar2, ar3, ar4, ar5, ma1, ma2, ma3, ma4, ma5, ma6))
xtable(signific %>% select(ma7, ma8, ma9, ma10, ma11, intercept))
#bonus: table avec les aic et bic de tous les modèles
selection_print_aic <- function(pmax, qmax){
res_aic <- matrix(nrow=pmax, ncol=qmax)
for (p in 1:pmax){
for (q in 1:qmax){
model <- arima(xm, c(p,0, q))
res_aic[p,q] <- model$aic
print(c(p,q))
}}
return(res_aic)
}
selec_aic <- selection_print_aic(pmax,qmax)
xtable((as.data.frame(selec_aic))%>%select(V1, V2, V3, V4, V5, V6, V7, V8, V9))
xtable((as.data.frame(selec_aic))%>%select(V8, V9, V10, V11))
selection_print_bic <- function(pmax, qmax){
res_bic <- matrix(nrow=pmax, ncol=qmax)
for (p in 1:pmax){
for (q in 1:qmax){
model <- arima(xm, c(p,0, q))
res_bic[p,q] <- BIC(model)
print(c(p,q))
}}
return(res_bic)
}
selec_bic <- selection_print_bic(pmax,qmax)
xtable((as.data.frame(selec_bic))%>%select(V1, V2, V3, V4, V5, V6, V7, V8, V9))
xtable((as.data.frame(selec_bic))%>%select(V8, V9, V10, V11))
