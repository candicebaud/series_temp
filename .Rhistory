axis(side=1,at=seq(0,300,12))
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
xm <- xm - mean(xm)
plot(xm)
acf(xm)
pacf(xm)
acf(xm)
pacf(xm)
dev.off()
acf(xm)
pacf(xm)
acf(xm)
pacf(xm)
acf(xm)
pacf(xm)
pacf(xm, lag = 30) #p peut aller jusqu'à l'infini msk ?  ou pareil on s'arrête vers 4-5 : pb à 12 aussi gros pic
pacf(xm, lag = 40) #p peut aller jusqu'à l'infini msk ?  ou pareil on s'arrête vers 4-5 : pb à 12 aussi gros pic
pacf(xm, lag = 50) #p peut aller jusqu'à l'infini msk ?  ou pareil on s'arrête vers 4-5 : pb à 12 aussi gros pic
acf(xm, lag = 50) #q peut aller jusqu'à 24??? ou bien on dit qu'on s'arrête en gros à 3?
#sélection du modèle ?
library(weakARMA)
pmax=26
qmax=12
#tester tous les modèles à la main
selection <- function(pmax, qmax){
res <- c(NA, NA)
AIC <- -Inf
for (p in 0:pmax){
for (q in 0:qmax){
model <- arima(xm, c(p,0, q))
if(model$aic>=AIC){
AIC <- model$aic
res[1] = p
res[2] = q
}
}
}
return(res)
}
#ne marche pas lol
selection(pmax, qmax)
#tous les modèles
selection_print <- function(pmax, qmax){
res_aic <- matrix(nrow=pmax, ncol=qmax)
for (p in 0:pmax){
for (q in 0:qmax){
model <- arima(xm, c(p,0, q))
res_aic[p,q] <- model$aic
}}
return(res)
}
selec <- selection_print(pmax,qmax)
selec
require(zoo)
require(tseries)
library(dplyr)
#base de données
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
View(data)
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
View(indice)
View(data)
xm.source <- zoo(indice[[1]])
T <- length(xm.source)
test <- tail(xm.source, n=4) #pour comparer nos prévisions avec les vraies données
xm <- xm.source[1:(T-4)]
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,400,12))
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
pp.test(xm) #test de philippe perron, on rejette à 1% l'hypothèse que la série n'est pas stationnaire
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,400,12))
dev.off()
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,400,12))
require(zoo)
require(tseries)
library(dplyr)
#base de données
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
xm <- xm.source[250:400] #pour le modèle
test <- tail(xm, n=4) #pour comparer nos prévisions avec les vraies données
require(zoo)
require(tseries)
library(dplyr)
#base de données
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
xm <- xm.source[250:] #pour le modèle
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
xm <- xm.source[(250):T] #pour le modèle
test <- tail(xm, n=4)
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,150,12))
axis(side=1,at=seq(0,400,12)) #pour mettre l'axe x
xm <- xm.source[(250):(T-4)] #pour le modèle
require(zoo)
require(tseries)
library(dplyr)
#base de données
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
test <- tail(xm, n=4) #pour comparer nos prévisions avec les vraies données
T <- length(xm.source)
test <- tail(xm, n=4) #pour comparer nos prévisions avec les vraies données
test <- tail(xm.source, n=4) #pour comparer nos prévisions avec les vraies données
xm <- xm.source[(250):(T-4)] #pour le modèle
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,400,12)) #pour mettre l'axe x
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
pp.test(xm) #test de philippe perron, on rejette à 1% l'hypothèse que la série n'est pas stationnaire
xm <- diff(xm, lag = 12)
plot(xm, xaxt="n")
dev.off()
plot(xm, xaxt="n")
plot(xm, xaxt="n")
axis(side=1,at=seq(0,300,12))
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
plot(xm, xaxt="n")
dev.off()
plot(xm, xaxt="n")
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
#on retire la moyenne de xm
xm <- xm - mean(xm)
plot(xm)
mean(xm)
acf(xm, lag = 30) #q peut aller jusqu'à 12??? ou bien on dit qu'on s'arrête en gros à 3?
pacf(xm, lag = 50)
dev.off()
acf(xm, lag = 30) #q peut aller jusqu'à 12??? ou bien on dit qu'on s'arrête en gros à 3?
pacf(xm, lag = 50)
acf(xm, lag = 30) #q peut aller jusqu'à 12??? ou bien on dit qu'on s'arrête en gros à 3?
#modèle
#tous les modèles
selection_print <- function(pmax, qmax){
res_aic <- matrix(nrow=pmax, ncol=qmax)
for (p in 0:pmax){
for (q in 0:qmax){
model <- arima(xm, c(p,0, q))
res_aic[p,q] <- model$aic
}}
return(res)
}
selec <- selection_print(pmax,qmax)
pmax = 13
qmax = 11
selec <- selection_print(pmax,qmax)
#modèle
#tous les modèles
selection_print <- function(pmax, qmax){
res_aic <- matrix(nrow=pmax, ncol=qmax)
for (p in 0:pmax){
for (q in 0:qmax){
model <- arima(xm, c(p,0, q))
res_aic[p,q] <- model$aic
print(p,q)
}}
return(res)
}
selec <- selection_print(pmax,qmax)
#modèle
#tous les modèles
selection_print <- function(pmax, qmax){
res_aic <- matrix(nrow=pmax, ncol=qmax)
for (p in 0:pmax){
for (q in 0:qmax){
model <- arima(xm, c(p,0, q))
res_aic[p,q] <- model$aic
print(c(p,q))
}}
return(res)
}
selec <- selection_print(pmax,qmax)
arima(xm, c(13,0,3))
arima(xm, c(13,0,4))
pmax = 12
qmax = 11
#modèle
#tous les modèles
selection_print <- function(pmax, qmax){
res_aic <- matrix(nrow=pmax, ncol=qmax)
for (p in 0:pmax){
for (q in 0:qmax){
model <- arima(xm, c(p,0, q))
res_aic[p,q] <- model$aic
print(c(p,q))
}}
return(res)
}
selec <- selection_print(pmax,qmax)
#modèle
#tous les modèles
selection_print <- function(pmax, qmax){
res_aic <- matrix(nrow=pmax, ncol=qmax)
for (p in 0:pmax){
for (q in 0:qmax){
model <- arima(xm, c(p,0, q))
res_aic[p,q] <- model$aic
print(c(p,q))
}}
return(res_aic)
}
selec <- selection_print(pmax,qmax)
selec
min(selec)
argmin(selec)
which.min(selec)
library(ramify)
library('ramify')
library('ramify')
argmin(selec)
View(selec)
min(selec)
argmax(selec)
which(m == min(selec),  arr.ind=TRUE)
which(selec == min(selec),  arr.ind=TRUE)
p = 5
q = 11
arma_fit <- arima(xm, c(5,0,11))
arma_fit
Box.test(arima_fit$residuals, lag=6, type="Ljung-Box", fitdf=5)
Box.test(arma_fit$residuals, lag=6, type="Ljung-Box", fitdf=5)
arma_fit$residuals
plot(arma_fit$residuals)
acf(arma_fit$residuals)
pacf(arma_fit$residuals)
#Q test
#test
Qtests <- function(series, k, fitdf=0) {
pvals <- apply(matrix(1:k), 1, FUN=function(l) {
pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
return(c("lag"=l,"pval"=pval))
})
return(t(pvals))
}
Qtests(arma_fit$residuals, 24, 5) #tests de LB pour les ordres 1 a 24
signif <- function(estim){ #fonction de test des significations individuelles des coefficients
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))*2
return(rbind(coef,se,pval))
}
signif(arma_fit)
model_pred <- predict(arma_fit, n.ahead=4)
ts.plot(xm, model_pred$pred, ylim = c(0, 200),
ylab = "CPI", col = "blue")
#prévision
model_pred <- predict(arma_fit, n.ahead=4)
model_pred
ts.plot(xm, model_pred$pred, ylim = c(0, 200),
ylab = "CPI", col = "blue")
serie_pred <- zoo(c(xm, model_pred$pred))
xm_all <- xm.source - mean(xm.source[1:(T-4)])
xm_all <- diff(xm_all, lag = 12)
plot(xm_all)
lines(serie_pred, col = 'red')
xm_all <- xm.source - mean(xm.source[250:(T-4)])
xm_all <- diff(xm_all, lag = 12)
plot(xm_all)
lines(serie_pred, col = 'red')
model_pred <- predict(arma_fit, n.ahead=4)
#ts.plot(xm, model_pred$pred, ylim = c(0, 200), ylab = "CPI", col = "blue")
serie_pred <- zoo(c(xm, model_pred$pred))
xm_all <- xm.source - mean(xm.source[250:(T-4)])
xm_all <- diff(xm_all, lag = 12)
plot(xm_all)
lines(serie_pred, col = 'red')
xm_all <- xm.source[250:T] - mean(xm.source[250:(T-4)])
xm_all <- diff(xm_all, lag = 12)
plot(xm_all)
lines(serie_pred, col = 'red')
plot(xm_all, col = 'red')
lines(serie_pred, col = 'black')
model_pred
xm_all <- xm.source[250:T] - mean(xm.source[250:(T-4)])
xm_all <- diff(xm_all, lag = 12)
plot(xm_all, col = 'red')
lines(serie_pred, col = 'black')
#intervalle de confiance
IC95_sup <- zoo(c(xm, model_pred$pred + 1.96*model_pred$se))
IC95_low <- zoo(c(xm, model_pred$pred - 1.96*model_pred$se))
lines(IC95_sup, col = 'blue')
lines(IC95_low, col = 'blue')
xm_all <- xm.source[250:T] - mean(xm.source[250:(T-4)])
xm_all <- diff(xm_all, lag = 12)
plot(xm_all, col = 'red')
lines(serie_pred, col = 'black')
#intervalle de confiance
IC95_sup <- zoo(model_pred$pred + 1.96*model_pred$se)
IC95_low <- zoo(model_pred$pred - 1.96*model_pred$se)
lines(IC95_sup, col = 'blue')
lines(IC95_low, col = 'blue')
#calcul erreur
rmse <- sqrt((model_pred$pred - xm_all[1:(T-4)])/4)
model_pred$pred
#calcul erreur
rmse <- sqrt((model_pred$pred - xm_all[1:(length(xm_all)-4)])/4)
#calcul erreur
rmse <- sqrt((model_pred$pred - tail(xm_all, n=4))/4)
#calcul erreur
rmse <- (model_pred$pred - tail(xm_all, n=4))/4
#calcul erreur
rmse <- (zoo(model_pred$pred) - tail(xm_all, n=4))/4
tail(xm_all, n=4)
as.data.frame(tail(xm_all, n=4))
as.data.frame(tail(xm_all, n=4))[1]
zoo(model_pred$pred)
zoo(model_pred$pred) - tail(xm_all, n=4)
sum((model_pred$pred - tail(xm_all, n=4))**2)
#calcul erreur
rmse <- sqrt(sum((model_pred$pred - tail(xm_all, n=4))**2)/4)
rmse
xm_all <- xm.source[250:T] - mean(xm.source[250:(T-4)])
xm_all <- diff(xm_all, lag = 12)
plot(xm_all, col = 'red')
lines(serie_pred, col = 'black')
#intervalle de confiance juste pour voir à modif
IC95_sup <- zoo(model_pred$pred + 1.96*model_pred$se/4)
IC95_low <- zoo(model_pred$pred - 1.96*model_pred$se/4)
lines(IC95_sup, col = 'blue')
lines(IC95_low, col = 'blue')
xm_all <- xm.source[250:T] - mean(xm.source[250:(T-4)])
xm_all <- diff(xm_all, lag = 12)
plot(xm_all, col = 'red')
lines(serie_pred, col = 'black')
#intervalle de confiance juste pour voir à modif
IC95_sup <- zoo(model_pred$pred + 1.96*model_pred$se/2)
IC95_low <- zoo(model_pred$pred - 1.96*model_pred$se/2)
lines(IC95_sup, col = 'blue')
lines(IC95_low, col = 'blue')
hist(arma_fit$residuals)
checkresiduals(naive(arma_fit$residuals))
library(forecast)
checkresiduals(arma_fit)
require(zoo)
require(tseries)
library(dplyr)
#base de données
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
test <- tail(xm.source, n=4) #pour comparer nos prévisions avec les vraies données
xm <- xm.source[(250):(T-4)]
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,400,12))
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
xm <- diff(xm, lag = 12)
plot(xm, xaxt="n")
axis(side=1,at=seq(0,300,12))
xm <- diff(xm, lag = 12)
plot(xm, xaxt="n")
axis(side=1,at=seq(0,400,12))
dev.off()
plot(xm, xaxt="n")
axis(side=1,at=seq(0,400,12))
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
test <- tail(xm.source, n=4) #pour comparer nos prévisions avec les vraies données
xm <- xm.source[(250):(T-4)] #pour le modèle
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,400,12)) #pour mettre l'axe x
par(mfrow=c(1,2))
acf(xm)
pacf(xm) #saisonnalité apparente : saisonnalité de 12 donc annuelle, avec été et hiver différenciés (corr pos et neg)
dev.off()
pp.test(xm) #test de philippe perron, on rejette à 1% l'hypothèse que la série n'est pas stationnaire
#on enlève la saisonnalité apparente
xm <- diff(xm, lag = 12)
plot(xm, xaxt="n")
axis(side=1,at=seq(0,400,12))
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
plot(xm, xaxt="n")
axis(side=1,at=seq(0,400,12))
dev.off()
plot(xm, xaxt="n")
axis(side=1,at=seq(0,400,12))
xm <- xm - mean(xm)
plot(xm, xaxt="n")
axis(side=1,at=seq(0,400,12))
acf(xm, lag = 30) #q peut aller jusqu'à 12??? ou bien on dit qu'on s'arrête en gros à 3?
pacf(xm, lag = 50)
pmax = 12
qmax = 11
p = 5
q = 11
arma_fit <- arima(xm, c(5,0,11))
arma_fit
checkresiduals(arma_fit)
arma_fit <- arima(xm, c(5,0,11))
arma_fit
signif(arma_fit)
signif <- function(estim){ #fonction de test des significations individuelles des coefficients
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))*2
return(rbind(coef,se,pval))
}
signif(arma_fit)
as.data.frame(signif(arma_fit))
signific <- as.data.frame(signif(arma_fit))
View(signific)
acf(xm, lag = 30) #q peut aller jusqu'à 12??? ou bien on dit qu'on s'arrête en gros à 3?
pacf(xm, lag = 50)
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
test <- tail(xm.source, n=4) #pour comparer nos prévisions avec les vraies données
xm <- xm.source[(250):(T-4)] #pour le modèle
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,400,12)) #pour mettre l'axe x
par(mfrow=c(1,2))
acf(xm)
pacf(xm) #saisonnalité apparente : saisonnalité de 12 donc annuelle, avec été et hiver différenciés (corr pos et neg)
dev.off()
pp.test(xm) #test de philippe perron, on rejette à 1% l'hypothèse que la série n'est pas stationnaire
#on enlève la saisonnalité apparente
xm <- diff(xm, lag = 12)
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
test <- tail(xm.source, n=4) #pour comparer nos prévisions avec les vraies données
xm <- xm.source[(250):(T-4)] #pour le modèle
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,400,12)) #pour mettre l'axe x
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
xm <- diff(xm, lag = 12)
par(mfrow=c(1,2))
acf(xm)
pacf(xm)
#on retire la moyenne de xm
xm <- xm - mean(xm)
pmax = 12
qmax = 11
p = 5
q = 11
arma_fit <- arima(xm, c(5,0,11))
arma_fit
checkresiduals(arma_fit)
Qtests <- function(series, k, fitdf=0) {
pvals <- apply(matrix(1:k), 1, FUN=function(l) {
pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
return(c("lag"=l,"pval"=pval))
})
return(t(pvals))
}
Qtests(arma_fit$residuals, 24, 5)
signif <- function(estim){ #fonction de test des significations individuelles des coefficients
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))*2
return(rbind(coef,se,pval))
}
signific <- as.data.frame(signif(arma_fit))
View(signific)
model_pred <- predict(arma_fit, n.ahead=4)
model_pred
arma_fit
serie_pred <- zoo(c(xm, model_pred$pred))
