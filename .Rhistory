df_during <- df_restr %>%
filter(covid_before_after == 'In-covid')
#data frame with only the values after covid
df_after <- df_restr %>%
filter(covid_before_after == 'Post-covid')
#data frames that count the number of victories before covid and all periods of time
df_wins_before <- df_restr %>%
filter(covid_before_after =='Pre-covid')%>%
filter(win == "1")%>%
select(team_name, team_status, win)%>%
group_by(team_name, team_status)%>%
summarise(number=n())%>%
mutate(numb_win = number)
df_wins_all <- df_restr %>%
select(team_name, team_status, win)%>%
filter(win == "1") %>%
group_by(team_name, team_status)%>%
summarise(number=n())%>%
mutate(numb_win = number)
df_wins_during <- df_restr %>%
filter(covid_before_after =='In-covid')%>%
filter(win == "1")%>%
select(team_name, team_status, win)%>%
group_by(team_name, team_status)%>%
summarise(number=n())%>%
mutate(numb_win = number)
df_wins_after <- df_restr %>%
filter(covid_before_after =='Post-covid')%>%
filter(win == "1")%>%
select(team_name, team_status, win)%>%
group_by(team_name, team_status)%>%
summarise(number=n())%>%
mutate(numb_win = number)
View(df_wins_after_bis)
View(df_restr)
View(df_restr)
df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status)%>%
summarise(number=n())%>%
mutate(numb_win = number)
df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
)
df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win)%>%
summarise(number=n())%>%
mutate(numb_win = sum(number))
df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win_numeric)%>%
summarise(number=n())%>%
mutate(numb_win = sum(number))
df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win_numeric)%>%
summarise()
df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win_numeric)%>%
summarise(s = sum(win_numeric))
df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win_numeric)%>%
summarise(number = n(),s = sum(win_numeric))
df_wins_during_bis
df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win_numeric)%>%
summarise(number = n(),s = sum(win_numeric)) %>%
group_by(team_name, team_status)%>%
summarise(sum = sum(s))
df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win_numeric)%>%
summarise(number = n(),s = sum(win_numeric))
df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win_numeric)%>%
summarise(number = n(),s = sum(win_numeric)) %>%
group_by(team_name, team_status)%>%
summarise(sum = sum(s))
df_wins_after_draw <- df_restr %>%
filter(covid_before_after =='Post-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win_numeric)%>%
summarise(number = n(),s = sum(win_numeric)) %>%
group_by(team_name, team_status)%>%
summarise(score = sum(s))
model_wins_after_draw <- glm(df_wins_after_draw$score ~ df_wins_after_draw$team_status, family=poisson(link="log"))
summary(model_wins_after_draw)
df_wins_before_draw <- df_restr %>%
filter(covid_before_after =='Pre-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win_numeric)%>%
summarise(number = n(),s = sum(win_numeric)) %>%
group_by(team_name, team_status)%>%
summarise(score = sum(s))
model_wins_before_draw <- glm(df_wins_before_draw$score ~ df_wins_before_draw$team_status, family=poisson(link="log"))
summary(model_wins_before_draw)
summary(model_wins_during_draw)
model_wins_before_draw <- glm(df_wins_before_draw$score ~ df_wins_before_draw$team_status, family=poisson(link="log"))
summary(model_wins_before_draw)
model_wins_during_draw <- glm(df_wins_during_draw$score ~ df_wins_during_draw$team_status, family=poisson(link="log"))
df_wins_during_draw
df_wins_during_draw <- df_restr %>%
filter(covid_before_after =='In-covid')%>%
select(team_name, team_status, win)%>%
mutate(
win_numeric = case_when(
win == 0 ~ 0,
win == 1 ~ 1,
win == 2 ~ 0.5
)
) %>%
group_by(team_name, team_status, win_numeric)%>%
summarise(number = n(),s = sum(win_numeric)) %>%
group_by(team_name, team_status)%>%
summarise(score = sum(s))
model_wins_during_draw <- glm(df_wins_during_draw$score ~ df_wins_during_draw$team_status, family=poisson(link="log"))
summary(model_wins_before_draw)
summary(model_wins_during_draw)
summary(model_wins_after_draw)
datafile <- "Donnees2.csv" #definit le fichier de donnees
data <- read.csv(datafile,sep=";") #importe un fichier .csv dans un objet de classe data.frame
setwd("C:/Users/candi/Desktop/ETUDES/ENSAE2A/semestre 2/séries temporelles")
data <- read.csv("Donnees2.csv",sep=";") #importe un fichier .csv dans un objet de classe data.frame
data <- read.csv("données2.csv",sep=";") #importe un fichier .csv dans un objet de classe data.frame
xm.source <- zoo(data[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
require(zoo) #format de serie temporelle pratique et facile d'utilisation (mais plus volumineux)
require(tseries) #diverses fonctions sur les series temporelles
xm.source <- zoo(data[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
xm <- xm.source[1:(T-4)]
plot(xm)
trend <- 1:length(xm)
lt <- lm(xm ~ trend) #
summary(lt) #
r <- lt$residuals #
par(mfrow=c(1,2))
plot(r)
acf(r)
pp.test(xm)
acf(r,24);pacf(r,24)
###
###
pmax=4; qmax=21
modelchoice <- function(p,q,data=r, k=24){
estim <- try(arima(data, c(p,0,q),optim.control=list(maxit=20000)))
if (class(estim)=="try-error") return(c("p"=p,"q"=q,"arsignif"=NA,"masignif"=NA,"resnocorr"=NA, "ok"=NA))
arsignif <- if (p==0) NA else signif(estim)[3,p]<=0.05
masignif <- if (q==0) NA else signif(estim)[3,p+q]<=0.05
resnocorr <- sum(Qtests(estim$residuals,24,length(estim$coef)-1)[,2]<=0.05,na.rm=T)==0
checks <- c(arsignif,masignif,resnocorr)
ok <- as.numeric(sum(checks,na.rm=T)==(3-sum(is.na(checks))))
return(c("p"=p,"q"=q,"arsignif"=arsignif,"masignif"=masignif,"resnocorr"=resnocorr,"ok"=ok))
}
armamodelchoice <- function(pmax,qmax){
pqs <- expand.grid(0:pmax,0:qmax)
t(apply(matrix(1:dim(pqs)[1]),1,function(row) {
p <- pqs[row,1]; q <- pqs[row,2]
cat(paste0("Computing ARMA(",p,",",q,") \n"))
modelchoice(p,q)
}))
}
armamodels <- armamodelchoice(pmax,qmax) #estime tous les arima (patienter...)
##
arimafit <- function(estim){
adjust <- round(signif(estim),3)
pvals <- Qtests(estim$residuals,24,length(estim$coef)-1)
pvals <- matrix(apply(matrix(1:24,nrow=6),2,function(c) round(pvals[c,],3)),nrow=6)
colnames(pvals) <- rep(c("lag", "pval"),4)
cat("tests de nullite des coefficients :\n")
print(adjust)
cat("\n tests d'absence d'autocorrelation des residus : \n")
print(pvals)
}
#### Q6 ####
#
signif <- function(estim){ #fonction de test des significations individuelles des coefficients
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))*2
return(rbind(coef,se,pval))
}
#
#
#
#
Qtests <- function(series, k, fitdf=0) {
pvals <- apply(matrix(1:k), 1, FUN=function(l) {
pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
return(c("lag"=l,"pval"=pval))
})
return(t(pvals))
}
modelchoice <- function(p,q,data=r, k=24){
estim <- try(arima(data, c(p,0,q),optim.control=list(maxit=20000)))
if (class(estim)=="try-error") return(c("p"=p,"q"=q,"arsignif"=NA,"masignif"=NA,"resnocorr"=NA, "ok"=NA))
arsignif <- if (p==0) NA else signif(estim)[3,p]<=0.05
masignif <- if (q==0) NA else signif(estim)[3,p+q]<=0.05
resnocorr <- sum(Qtests(estim$residuals,24,length(estim$coef)-1)[,2]<=0.05,na.rm=T)==0
checks <- c(arsignif,masignif,resnocorr)
ok <- as.numeric(sum(checks,na.rm=T)==(3-sum(is.na(checks))))
return(c("p"=p,"q"=q,"arsignif"=arsignif,"masignif"=masignif,"resnocorr"=resnocorr,"ok"=ok))
}
## fonction pour estimer et verifier tous les arima(p,q) avec p<=pmax et q<=max
armamodelchoice <- function(pmax,qmax){
pqs <- expand.grid(0:pmax,0:qmax)
t(apply(matrix(1:dim(pqs)[1]),1,function(row) {
p <- pqs[row,1]; q <- pqs[row,2]
cat(paste0("Computing ARMA(",p,",",q,") \n"))
modelchoice(p,q)
}))
}
armamodels <- armamodelchoice(pmax,qmax) #estime tous les arima (patienter...)
selec <- armamodels[armamodels[,"ok"]==1&!is.na(armamodels[,"ok"]),] #modeles bien ajustes et valides
selec
pqs <- apply(selec,1,function(row) list("p"=as.numeric(row[1]),"q"=as.numeric(row[2]))) #cree une liste des ordres p et q des modeles candidats
pqs
names(pqs) <- paste0("arma(",selec[,1],",",selec[,2],")") #renomme les elements de la liste
names(pqs)
models <- lapply(pqs, function(pq) arima(r,c(pq[["p"]],0,pq[["q"]]))) #cree une liste des modeles candidats estimes
vapply(models, FUN.VALUE=numeric(2), function(m) c("AIC"=AIC(m),"BIC"=BIC(m))) #calcule les AIC et BIC des modeles candidats
rps <- lapply(models, function(m) as.zoo(predict(m,4)$pred)) #previsions de r
xmps <- lapply(rps, function(rp) rp+cbind(1,c((T-3):T))%*%lt$coefficients) #previsions de xm
rmse <- vapply(xmps, FUN.VALUE=numeric(1), function(xmp) sqrt(sum((as.zoo(xmp)-tail(xm.source,4))^2))) #calcule les rmse out-of-sample
rmse
setwd("C:/Users/candi/Desktop/ETUDES/ENSAE2A/semestre 2/séries temporelles/series temp/series_temp")
require(zoo)
require(tseries)
library(dplyr)
#base de données
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
test <- tail(xm.source, n=112) #pour comparer nos prévisions avec les vraies données
xm <- xm.source[1:(T-100)] #pour le modèle
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,300,12)) #pour mettre l'axe x
#xm <- xm - mean(xm) #pour enlever la moyenne
par(mfrow=c(1,2))
acf(xm)
pacf(xm) #saisonnalité apparente : saisonnalité de 12 donc annuelle
dev.off()
#on enlève la saisonnalité apparente
xm <- diff(xm, lag = 12)
plot(xm, xaxt="n")
axis(side=1,at=seq(0,300,12))
par(mfrow=c(1,2))
acf(xm)
pacf(xm) #la saisonnalité a bien disparu sauf sur la pacf
pp.test(xm) #
xm <- xm - mean(xm)
plot(xm)
acf(xm)
pacf(xm)
Qtests <- function(series, k, fitdf=0) {
pvals <- apply(matrix(1:k), 1, FUN=function(l) {
pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
return(c("lag"=l,"pval"=pval))
})
return(t(pvals))
}
signif <- function(estim){ #fonction de test des significations individuelles des coefficients
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))*2
return(rbind(coef,se,pval))
}
#sélection du modèle
## fonction pour estimer un arima et en verifier l'ajustement et la validite
modelchoice <- function(p,q,data=r, k=24){
estim <- try(arima(data, c(p,0,q),optim.control=list(maxit=20000)))
if (class(estim)=="try-error") return(c("p"=p,"q"=q,"arsignif"=NA,"masignif"=NA,"resnocorr"=NA, "ok"=NA))
arsignif <- if (p==0) NA else signif(estim)[3,p]<=0.05
masignif <- if (q==0) NA else signif(estim)[3,p+q]<=0.05
resnocorr <- sum(Qtests(estim$residuals,24,length(estim$coef)-1)[,2]<=0.05,na.rm=T)==0
checks <- c(arsignif,masignif,resnocorr)
ok <- as.numeric(sum(checks,na.rm=T)==(3-sum(is.na(checks))))
return(c("p"=p,"q"=q,"arsignif"=arsignif,"masignif"=masignif,"resnocorr"=resnocorr,"ok"=ok))
}
## fonction pour estimer et verifier tous les arima(p,q) avec p<=pmax et q<=max
armamodelchoice <- function(pmax,qmax){
pqs <- expand.grid(0:pmax,0:qmax)
t(apply(matrix(1:dim(pqs)[1]),1,function(row) {
p <- pqs[row,1]; q <- pqs[row,2]
cat(paste0("Computing ARMA(",p,",",q,") \n"))
modelchoice(p,q)
}))
}
pmax=12
qmax=5
#on fait tous les modèles
armamodels <- armamodelchoice(pmax,qmax) #estime tous les arima (patienter...)
#on sélectionne ceux qui sont bien
selec <- armamodels[armamodels[,"ok"]==1&!is.na(armamodels[,"ok"]),] #modeles bien ajustes et valides
selec
#on évalue avec le AIC, BIC et le RMSE sur la prédiction
pqs <- apply(selec,1,function(row) list("p"=as.numeric(row[1]),"q"=as.numeric(row[2]))) #cree une liste des ordres p et q des modeles candidats
names(pqs) <- paste0("arma(",selec[,1],",",selec[,2],")") #renomme les elements de la liste
models <- lapply(pqs, function(pq) arima(r,c(pq[["p"]],0,pq[["q"]]))) #cree une liste des modeles candidats estimes
vapply(models, FUN.VALUE=numeric(2), function(m) c("AIC"=AIC(m),"BIC"=BIC(m))) #calcule les AIC et BIC des modeles candidats
rps <- lapply(models, function(m) as.zoo(predict(m,4)$pred)) #previsions de r
xmps <- lapply(rps, function(rp) rp+cbind(1,c((T-3):T))%*%lt$coefficients) #previsions de xm
rmse <- vapply(xmps, FUN.VALUE=numeric(1), function(xmp) sqrt(sum((as.zoo(xmp)-tail(xm.source,4))^2))) #calcule les rmse out-of-sample
rmse
rps <- lapply(models, function(m) as.zoo(predict(m,4)$pred)) #previsions de r
rps
rps <- lapply(models, function(m) as.zoo(predict(m,112)$pred)) #previsions de r
rps
xmps <- lapply(rps, function(rp) rp+cbind(1,c((T-111):T))%*%lt$coefficients) #previsions de xm
rmse <- vapply(xmps, FUN.VALUE=numeric(1), function(xmp) sqrt(sum((as.zoo(xmp)-tail(xm.source,112))^2))) #calcule les rmse out-of-sample
rmse
data <- read.csv('valeurs_mensuelles_pesticides.csv', sep=";")
data <- data[2]
data <- as.data.frame(data[-(1:3),])#on enlève les premières lignes qui ne sont pas des données
indice <- as.data.frame(as.numeric(unlist(data)))
xm.source <- zoo(indice[[1]]) #convertit le premier element de data en serie temporelle de type "zoo"
T <- length(xm.source)
test <- tail(xm.source, n=4) #pour comparer nos prévisions avec les vraies données
xm <- xm.source[1:(T-4)] #pour le modèle
plot(xm, xaxt="n") #plot des données
axis(side=1,at=seq(0,300,12)) #pour mettre l'axe x
#xm <- xm - mean(xm) #pour enlever la moyenne
par(mfrow=c(1,2))
acf(xm)
pacf(xm) #saisonnalité apparente : saisonnalité de 12 donc annuelle
dev.off()
#on enlève la saisonnalité apparente
xm <- diff(xm, lag = 12)
plot(xm, xaxt="n")
axis(side=1,at=seq(0,300,12))
par(mfrow=c(1,2))
acf(xm)
pacf(xm) #la saisonnalité a bien disparu sauf sur la pacf
pp.test(xm)
xm <- xm - mean(xm)
plot(xm)
acf(xm)
pacf(xm)
#test
arima_1 <- arima(xm, c(2,0,5))
arima_1
Box.test(arima_1$residuals, lag=6, type="Ljung-Box", fitdf=5)
Qtests <- function(series, k, fitdf=0) {
pvals <- apply(matrix(1:k), 1, FUN=function(l) {
pval <- if (l<=fitdf) NA else Box.test(series, lag=l, type="Ljung-Box", fitdf=fitdf)$p.value
return(c("lag"=l,"pval"=pval))
})
return(t(pvals))
}
signif <- function(estim){ #fonction de test des significations individuelles des coefficients
coef <- estim$coef
se <- sqrt(diag(estim$var.coef))
t <- coef/se
pval <- (1-pnorm(abs(t)))*2
return(rbind(coef,se,pval))
}
Qtests(arima_1$residuals, 24, 5) #tests de LB pour les ordres 1 a 24
round(Qtests(arima_1$residuals,24,fitdf=5),3)
#sélection du modèle
## fonction pour estimer un arima et en verifier l'ajustement et la validite
modelchoice <- function(p,q,data=r, k=24){
estim <- try(arima(data, c(p,0,q),optim.control=list(maxit=20000)))
if (class(estim)=="try-error") return(c("p"=p,"q"=q,"arsignif"=NA,"masignif"=NA,"resnocorr"=NA, "ok"=NA))
arsignif <- if (p==0) NA else signif(estim)[3,p]<=0.05
masignif <- if (q==0) NA else signif(estim)[3,p+q]<=0.05
resnocorr <- sum(Qtests(estim$residuals,24,length(estim$coef)-1)[,2]<=0.05,na.rm=T)==0
checks <- c(arsignif,masignif,resnocorr)
ok <- as.numeric(sum(checks,na.rm=T)==(3-sum(is.na(checks))))
return(c("p"=p,"q"=q,"arsignif"=arsignif,"masignif"=masignif,"resnocorr"=resnocorr,"ok"=ok))
}
## fonction pour estimer et verifier tous les arima(p,q) avec p<=pmax et q<=max
armamodelchoice <- function(pmax,qmax){
pqs <- expand.grid(0:pmax,0:qmax)
t(apply(matrix(1:dim(pqs)[1]),1,function(row) {
p <- pqs[row,1]; q <- pqs[row,2]
cat(paste0("Computing ARMA(",p,",",q,") \n"))
modelchoice(p,q)
}))
}
pmax=12
qmax=5
#on fait tous les modèles
armamodels <- armamodelchoice(pmax,qmax) #estime tous les arima (patienter...)
selec <- armamodels[armamodels[,"ok"]==1&!is.na(armamodels[,"ok"]),] #modeles bien ajustes et valides
selec
#on évalue avec le AIC, BIC et le RMSE sur la prédiction
pqs <- apply(selec,1,function(row) list("p"=as.numeric(row[1]),"q"=as.numeric(row[2]))) #cree une liste des ordres p et q des modeles candidats
names(pqs) <- paste0("arma(",selec[,1],",",selec[,2],")") #renomme les elements de la liste
models <- lapply(pqs, function(pq) arima(r,c(pq[["p"]],0,pq[["q"]]))) #cree une liste des modeles candidats estimes
vapply(models, FUN.VALUE=numeric(2), function(m) c("AIC"=AIC(m),"BIC"=BIC(m))) #calcule les AIC et BIC des modeles candidats
rps <- lapply(models, function(m) as.zoo(predict(m,4)$pred)) #previsions de r
xmps <- lapply(rps, function(rp) rp+cbind(1,c((T-3):T))%*%lt$coefficients) #previsions de xm
rmse <- vapply(xmps, FUN.VALUE=numeric(1), function(xmp) sqrt(sum((as.zoo(xmp)-tail(xm.source,4))^2))) #calcule les rmse out-of-sample
rmse
rps <- lapply(models, function(m) as.zoo(predict(m,4)$pred)) #previsions de r
rps
xmps <- lapply(rps, function(rp) rp+cbind(1,c((T-3):T))%>%lt$coefficients) #previsions de xm
xmps <- lapply(rps, function(rp) rp+cbind(1,c((T-3):T))%>%lt$coefficients) #previsions de xm
trend <- 1:length(xm)
lt <- lm(xm ~ trend)
xmps <- lapply(rps, function(rp) rp+cbind(1,c((T-3):T))%*%lt$coefficients) #previsions de xm
rmse <- vapply(xmps, FUN.VALUE=numeric(1), function(xmp) sqrt(sum((as.zoo(xmp)-tail(xm.source,4))^2))) #calcule les rmse out-of-sample
rmse
rps
rps$arma(5,0)
rps$arma(5,0)
rps
rps$`arma(5,0)
rps$arma(5,0)
kfaezpofka
